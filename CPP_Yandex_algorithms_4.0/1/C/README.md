[К оглавлению](../../README.md)

## C. Слияние

Ограничение времени	5 секунд
Ограничение памяти	512Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Базовый алгоритм для сортировки слиянием — алгоритм слияния двух упорядоченных массивов в один упорядоченный массив. Эта операция выполняется за линейное время с линейным потреблением памяти. Реализуйте слияние двух массивов в качестве первого шага для написания сортировки слиянием.

Формат ввода
В первой строке входного файла содержится число N — количество элементов первого массива (0 ≤ N ≤ 106).
Во второй строке содержатся N целых чисел ai, разделенных пробелами, отсортированные по неубыванию (-109 ≤ ai ≤ 109).
В третьей строке входного файла содержится число M — количество элементов второго массива (0 ≤ M ≤ 106).
В третьей строке содежатся M целых чисел bi, разделенных пробелами, отсортированные по неубыванию (-109 ≤ bi ≤ 109).

Формат вывода
Выведите результат слияния этих двух массивов, то есть M + N целых чисел, разделенных пробелами, в порядке неубывания.

Примечания
Для решения этой задачи советуем реализовать функцию, которая принимает на вход две пары итераторов, задающие два массива, и итератор на начало буфера, в который необходимо записывать результат. Итераторы можжно заменить на передачу массивов и индексов в них. В таком виде вам будет удобно использовать эту функцию для реализации сортировки.

```cpp
#include <iostream>
#include <vector>

int main() {
    const size_t d = 1000000;
    int n;  //, l, r;

    std::vector<int> ar1(d);
    std::cin >> n;
    for (int i = 0; i < n; ++i) {
        std::cin >> ar1[i];
    }
    ar1.resize(n);
    int m;
    std::vector<int> ar2(d);
    std::cin >> m;
    for (int i = 0; i < m; ++i) {
        std::cin >> ar2[i];
    }
    ar2.resize(m);
    std::vector<int> res(ar1.size() + ar2.size());
    size_t index1 = 0, index2 = 0;
    for (size_t i = 0; i != res.size(); ++i) {
        if (ar1[index1] < ar2[index2] && index1 < ar1.size()) {
            res[i] = ar1[index1];
            ++index1;
        } else if (index2 < ar2.size() && index1 >= ar1.size()) {
            res[i] = ar2[index2];
            index2++;
        } else if (ar1[index1] > ar2[index2] && index2 < ar2.size()) {
            res[i] = ar2[index2];
            index2++;
        } else if (index1 < ar1.size() && index2 >= ar2.size()) {
            res[i] = ar1[index1];
            index1++;
        } else if (ar1[index1] == ar2[index2]) {
            res[i] = ar1[index1];
            if (index1 < ar1.size()) {
                ++index1;
            }
        }
    }
    for (size_t i = 0; i != res.size(); ++i) {
        std::cout << res[i] << " ";
    }
}
```